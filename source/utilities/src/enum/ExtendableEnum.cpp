#include "ExtendableEnum.h"

namespace utl
{
//////////////////////////////////////////////////////////////////
/// ExtendableEnum::ExtendableEnum()
//////////////////////////////////////////////////////////////////
ExtendableEnum::ExtendableEnum(void) {}

//////////////////////////////////////////////////////////////////
/// ExtendableEnum::~ExtendableEnum()
//////////////////////////////////////////////////////////////////
ExtendableEnum::~ExtendableEnum(void) {}

//////////////////////////////////////////////////////////////////
/// ExtendableEnum::addEnumerationLiteral()
//////////////////////////////////////////////////////////////////
template <typename T>
bool ExtendableEnum::addEnumerationLiteral(const T enumValue)
{
    return m_enumerationMap
        .insert(std::pair<ExtendableEnumLiteral, bool>(
            ExtendableEnumLiteral(static_cast<uint64_t>(enumValue)), true))
        .second;
}

//////////////////////////////////////////////////////////////////
/// ExtendableEnum::addEnumerationLiteral()
//////////////////////////////////////////////////////////////////
bool ExtendableEnum::addEnumerationLiteral(const ExtendableEnumLiteral& literal)
{
    return m_enumerationMap
        .insert(std::pair<ExtendableEnumLiteral, bool>(literal, true))
        .second;
}

//////////////////////////////////////////////////////////////////
/// ExtendableEnum::isValid()
//////////////////////////////////////////////////////////////////
template <typename T>
bool ExtendableEnum::isValid(const T enumValue)
{
    return m_enumerationMap.find(ExtendableEnumLiteral(
               static_cast<uint64_t>(enumValue))) != m_enumerationMap.end();
}

//////////////////////////////////////////////////////////////////
/// ExtendableEnum::isValid()
//////////////////////////////////////////////////////////////////
bool ExtendableEnum::isValid(const ExtendableEnumLiteral& literal)
{
    return m_enumerationMap.find(literal) != m_enumerationMap.end();
}
} // namespace utl
